  export namespace workspace {
    export const nvim: Neovim
    /**
     * Current buffer number, could be wrong since vim could not send autocmd as expected.
     *
     * @deprecated will be removed in the feature.
     */
    export const bufnr: number
    /**
     * Current document.
     */
    export const document: Promise<Document>
    /**
     * Environments or current (neo)vim.
     */
    export const env: Env
    /**
     * Float window or popup can work.
     */
    export const floatSupported: boolean
    /**
     * Current working directory of vim.
     */
    export const cwd: string
    /**
     * Current workspace root.
     */
    export const root: string
    /**
     * @deprecated aliased to root.
     */
    export const rootPath: string
    /**
     * Not neovim when true.
     */
    export const isVim: boolean
    /**
     * Is neovim when true.
     */
    export const isNvim: boolean
    /**
     * Is true when current mode is insert, could be wrong when user cancel insert by <C-c>
     *
     * @deprecated
     */
    export const insertMode: boolean
    /**
     * All filetypes of loaded documents.
     */
    export const filetypes: ReadonlySet<string>
    /**
     * Root directory of coc.nvim
     */
    export const pluginRoot: string
    /**
     * Current `&completeopt` of vim, may not correct.
     */
    export const completeOpt: string
    /**
     * Exists channel names.
     */
    export const channelNames: ReadonlyArray<string>
    /**
     * Current document array.
     */
    export const documents: ReadonlyArray<Document>
    /**
     * Current document array.
     */
    export const textDocuments: ReadonlyArray<TextDocument>
    /**
     * Current workspace folders.
     */
    export const workspaceFolders: ReadonlyArray<WorkspaceFolder>
    /**
     * Directory paths of workspaceFolders.
     */
    export const folderPaths: ReadonlyArray<string>
    /**
     * Current workspace folder, could be null when vim started from user's home.
     */
    export const workspaceFolder: WorkspaceFolder | null
    /**
     * Event fired after terminal created, only fired with Terminal that created
     * by `workspace.createTerminal`
     */
    export const onDidOpenTerminal: Event<Terminal>
    /**
     * Event fired on terminal close, only fired with Terminal that created by
     * `workspace.createTerminal`
     */
    export const onDidCloseTerminal: Event<Terminal>
    /**
     * Event fired on workspace folder change.
     */
    export const onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent>
    /**
     * Event fired after document create.
     */
    export const onDidOpenTextDocument: Event<TextDocument & { bufnr: number }>
    /**
     * Event fired after document unload.
     */
    export const onDidCloseTextDocument: Event<TextDocument & { bufnr: number }>
    /**
     * Event fired on document change.
     */
    export const onDidChangeTextDocument: Event<DidChangeTextDocumentParams>
    /**
     * Event fired before document save.
     */
    export const onWillSaveTextDocument: Event<WillSaveEvent>
    /**
     * Event fired after document save.
     */
    export const onDidSaveTextDocument: Event<TextDocument>

    /**
     * Event fired on configuration change. Configuration change could by many
     * reasons, including:
     *
     * - Changes detected from `coc-settings.json`.
     * - Change to document that using another configuration file.
     * - Configuration change by call update API of WorkspaceConfiguration.
     */
    export const onDidChangeConfiguration: Event<ConfigurationChangeEvent>

    /**
     * Fired when vim's runtimepath change detected.
     */
    export const onDidRuntimePathChange: Event<ReadonlyArray<string>>

    /**
     * Create new namespace id by name.
     */
    export function createNameSpace(name: string): number

    /**
     * Register autocmd on vim.
     *
     * Note: avoid request autocmd when possible since vim could be blocked
     * forever when request triggered during request.
     */
    export function registerAutocmd(autocmd: Autocmd): Disposable

    /**
     * Watch for vim's global option change.
     */
    export function watchOption(key: string, callback: (oldValue: any, newValue: any) => Thenable<void> | void, disposables?: Disposable[]): void

    /**
     * Watch for vim's global variable change, works on neovim only.
     */
    export function watchGlobal(key: string, callback?: (oldValue: any, newValue: any) => Thenable<void> | void, disposables?: Disposable[]): void

    /**
     * Check if selector match document.
     */
    export function match(selector: DocumentSelector, document: TextDocument): number

    /**
     * Findup from filename or filenames from current filepath or root.
     *
     * @return fullpath of file or null when not found.
     */
    export function findUp(filename: string | string[]): Promise<string | null>

    /**
     * Resolve root folder of uri with match patterns.
     * Cwd is returned when uri is not file scheme.
     * Parent folder of uri is returned when failed to resolve.
     *
     * @deprecated avoid use it when possible.
     */
    export function resolveRootFolder(uri: Uri, patterns: string[]): Promise<string>

    /**
     * Get possible watchman binary path.
     */
    export function getWatchmanPath(): string | null

    /**
     * Get configuration by section and optional resource uri.
     */
    export function getConfiguration(section?: string, resource?: string): WorkspaceConfiguration

    /**
     * Get created document by uri or bufnr.
     */
    export function getDocument(uri: number | string): Document

    /**
     * Apply WorkspaceEdit.
     */
    export function applyEdit(edit: WorkspaceEdit): Promise<boolean>

    /**
     * Convert location to quickfix item.
     */
    export function getQuickfixItem(loc: Location | LocationLink, text?: string, type?: string, module?: string): Promise<QuickfixItem>

    /**
     * Get selected range for current document
     */
    export function getSelectedRange(visualmode: string, document: Document): Promise<Range | null>

    /**
     * Visual select range of current document
     */
    export function selectRange(range: Range): Promise<void>

    /**
     * Populate locations to UI.
     */
    export function showLocations(locations: Location[]): Promise<void>

    /**
     * Get content of line by uri and line.
     */
    export function getLine(uri: string, line: number): Promise<string>

    /**
     * Get WorkspaceFolder of uri
     */
    export function getWorkspaceFolder(uri: string): WorkspaceFolder | null

    /**
     * Get content from buffer of file by uri.
     */
    export function readFile(uri: string): Promise<string>

    /**
     * Get current document and position.
     */
    export function getCurrentState(): Promise<EditerState>

    /**
     * Get format options of uri or current buffer.
     */
    export function getFormatOptions(uri?: string): Promise<FormattingOptions>

    /**
     * Jump to location.
     */
    export function jumpTo(uri: string, position?: Position | null, openCommand?: string): Promise<void>

    /**
     * Create a file in vim and disk
     */
    export function createFile(filepath: string, opts?: CreateFileOptions): Promise<void>

    /**
     * Load uri as document, buffer would be invisible if not loaded.
     */
    export function loadFile(uri: string): Promise<Document>

    /**
     * Load the files that not loaded
     */
    export function loadFiles(uris: string[]): Promise<void>

    /**
     * Rename file in vim and disk
     */
    export function renameFile(oldPath: string, newPath: string, opts?: RenameFileOptions): Promise<void>

    /**
     * Delete file from vim and disk.
     */
    export function deleteFile(filepath: string, opts?: DeleteFileOptions): Promise<void>

    /**
     * Open resource by uri
     */
    export function openResource(uri: string): Promise<void>

    /**
     * Resovle full path of module from yarn or npm global directory.
     */
    export function resolveModule(name: string): Promise<string>

    /**
     * Run nodejs command
     */
    export function runCommand(cmd: string, cwd?: string, timeout?: number): Promise<string>

    /**
     * Expand filepath with `~` and/or environment placeholders
     */
    export function expand(filepath: string): string

    /**
     * Call a function by use notifications, useful for functions like |input| that could block vim.
     */
    export function callAsync<T>(method: string, args: any[]): Promise<T>

    /**
     * registerTextDocumentContentProvider
     */
    export function registerTextDocumentContentProvider(scheme: string, provider: TextDocumentContentProvider): Disposable

    /**
     * Register unique keymap uses `<Plug>(coc-{key})` as lhs
     * Throw error when {key} already exists.
     *
     * @param {MapMode[]} modes - array of 'n' | 'i' | 'v' | 'x' | 's' | 'o'
     * @param {string} key - unique name
     * @param {Function} fn - callback function
     * @param {Partial} opts
     * @returns {Disposable}
     */
    export function registerKeymap(modes: MapMode[], key: string, fn: () => ProviderResult<any>, opts?: Partial<KeymapOption>): Disposable

    /**
     * Register expr key-mapping.
     */
    export function registerExprKeymap(mode: 'i' | 'n' | 'v' | 's' | 'x', key: string, fn: () => ProviderResult<string>, buffer?: boolean): Disposable

    /**
     * Register local key-mapping.
     */
    export function registerLocalKeymap(mode: 'n' | 'v' | 's' | 'x', key: string, fn: () => ProviderResult<any>, notify?: boolean): Disposable

    /**
     * Register for buffer sync objects, created item should be disposable
     * and provide optional `onChange` which called when document change.
     *
     * The document is always attached and not command line buffer.
     * 
     * @param create Called for each attached document and on document create.
     * @returns Disposable
     */
    export function registerBufferSync<T extends BufferSyncItem>(create: (doc: Document) => T): Disposable

    /**
     * Create a FileSystemWatcher instance, when watchman not exists, the
     * returned FileSystemWatcher can stil be used, but not work at all.
     */
    export function createFileSystemWatcher(globPattern: string, ignoreCreate?: boolean, ignoreChange?: boolean, ignoreDelete?: boolean): FileSystemWatcher
    /**
     * Create persistence Mru instance.
     */
    export function createMru(name: string): Mru

    /**
     * Create Task instance that runs in (neo)vim, no shell.
     *
     * @param id Unique id string, like `TSC`
     */
    export function createTask(id: string): Task

    /**
     * Create terminal in (neo)vim.
     */
    export function createTerminal(opts: TerminalOptions): Promise<Terminal>

    /**
     * Create DB instance at extension root.
     */
    export function createDatabase(name: string): JsonDB
  }
