SCRIPT  C:\home\vimfiles\plugins\vim-wakatime\plugin\wakatime.vim
Sourced 1 time
Total time:   0.001459
 Self time:   0.000786

count  total (s)   self (s)
                            " ============================================================================
                            " File:        wakatime.vim
                            " Description: Automatic time tracking for Vim.
                            " Maintainer:  WakaTime <support@wakatime.com>
                            " License:     BSD, see LICENSE.txt for more details.
                            " Website:     https://wakatime.com/
                            " ============================================================================
                            
    1              0.000007 let s:VERSION = '7.0.7'
                            
                            
                            " Init {{{
                            
                                " Check Vim version
    1              0.000002     if v:version < 700
                                    echoerr "This plugin requires vim >= 7."
                                    finish
                                endif
                            
                                " Use constants for truthy check to improve readability
    1              0.000001     let s:true = 1
    1              0.000001     let s:false = 0
                            
                                " Only load plugin once
    1              0.000004     if exists("g:loaded_wakatime")
                                    finish
                                endif
    1              0.000001     let g:loaded_wakatime = s:true
                            
                                " Backup & Override cpoptions
    1              0.000005     let s:old_cpo = &cpo
    1              0.000005     set cpo&vim
                            
                                " Backup wildignore before clearing it to prevent conflicts with expand()
    1              0.000002     let s:wildignore = &wildignore
    1              0.000002     if s:wildignore != ""
                                    set wildignore=""
                                endif
                            
                                " Script Globals
    1              0.000034     let s:home = expand("$WAKATIME_HOME")
    1              0.000002     if s:home == '$WAKATIME_HOME'
    1              0.000062         let s:home = expand("$HOME")
    1              0.000002     endif
    1              0.000068     let s:cli_location = expand("<sfile>:p:h") . '/packages/wakatime/cli.py'
    1              0.000003     let s:config_file = s:home . '/.wakatime.cfg'
    1              0.000004     let s:default_configs = ['[settings]', 'debug = false', 'hidefilenames = false', 'ignore =', '    COMMIT_EDITMSG$', '    PULLREQ_EDITMSG$', '    MERGE_MSG$', '    TAG_EDITMSG$']
    1              0.000002     let s:data_file = s:home . '/.wakatime.data'
    1              0.000041     let s:has_reltime = has('reltime') && localtime() - 1 < split(split(reltimestr(reltime()))[0], '\.')[0]
    1              0.000002     let s:config_file_already_setup = s:false
    1              0.000002     let s:debug_mode_already_setup = s:false
    1              0.000002     let s:is_debug_on = s:false
    1              0.000002     let s:local_cache_expire = 10  " seconds between reading s:data_file
    1              0.000004     let s:last_heartbeat = {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
    1              0.000002     let s:heartbeats_buffer = []
    1              0.000002     let s:send_buffer_seconds = 10  " seconds between sending buffered heartbeats
    1              0.000002     let s:last_sent = localtime()
    1              0.000008     let s:has_async = has('patch-7.4-2344') && exists('*job_start')
    1              0.000002     let s:nvim_async = exists('*jobstart')
                            
    1              0.000002     function! s:Init()
                            
                                    " For backwards compatibility, rename wakatime.conf to wakatime.cfg
                                    if !filereadable(s:config_file)
                                        if filereadable(expand("$HOME/.wakatime"))
                                            exec "silent !mv" expand("$HOME/.wakatime") expand("$HOME/.wakatime.conf")
                                        endif
                                        if filereadable(expand("$HOME/.wakatime.conf"))
                                            if !filereadable(s:config_file)
                                                let contents = ['[settings]'] + readfile(expand("$HOME/.wakatime.conf"), '')
                                                call writefile(contents, s:config_file)
                                                call delete(expand("$HOME/.wakatime.conf"))
                                            endif
                                        endif
                                    endif
                            
                                    " Set default python binary location
                                    if !exists("g:wakatime_PythonBinary")
                                        let g:wakatime_PythonBinary = 'python'
                                    endif
                            
                                    " Set default heartbeat frequency in minutes
                                    if !exists("g:wakatime_HeartbeatFrequency")
                                        let g:wakatime_HeartbeatFrequency = 2
                                    endif
                            
                                    " Get legacy g:wakatime_ScreenRedraw setting
                                    let s:redraw_setting = 'auto'
                                    if exists("g:wakatime_ScreenRedraw") && g:wakatime_ScreenRedraw
                                        let s:redraw_setting = 'enabled'
                                    endif
                            
                                    " Get redraw setting from wakatime.cfg file
                                    if s:GetIniSetting('settings', 'vi_redraw') != ''
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'enabled'
                                            let s:redraw_setting = 'enabled'
                                        endif
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'auto'
                                            let s:redraw_setting = 'auto'
                                        endif
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'disabled'
                                            let s:redraw_setting = 'disabled'
                                        endif
                                    endif
                            
                                    " Buffering heartbeats disabled in Windows, unless have async support
                                    let s:buffering_heartbeats_enabled = s:has_async || s:nvim_async || !s:IsWindows()
                            
                                endfunction
                            
                            " }}}
                            
                            
                            " Function Definitions {{{
                            
    1              0.000002     function! s:StripWhitespace(str)
                                    return substitute(a:str, '^\s*\(.\{-}\)\s*$', '\1', '')
                                endfunction
                            
    1              0.000001     function! s:SetupConfigFile()
                                    if !s:config_file_already_setup
                            
                                        " Create config file if does not exist
                                        if !filereadable(s:config_file)
                                            call writefile(s:default_configs, s:config_file)
                                        endif
                            
                                        " Make sure config file has api_key
                                        let found_api_key = s:false
                                        if s:GetIniSetting('settings', 'api_key') != '' || s:GetIniSetting('settings', 'apikey') != ''
                                            let found_api_key = s:true
                                        endif
                                        if !found_api_key
                                            call s:PromptForApiKey()
                                            echo "[WakaTime] Setup complete! Visit https://wakatime.com to view your coding activity."
                                        endif
                            
                                        let s:config_file_already_setup = s:true
                                    endif
                                endfunction
                            
    1              0.000001     function! s:SetupDebugMode()
                                    if !s:debug_mode_already_setup
                                        if s:GetIniSetting('settings', 'debug') == 'true'
                                            let s:is_debug_on = s:true
                                        else
                                            let s:is_debug_on = s:false
                                        endif
                                        let s:debug_mode_already_setup = s:true
                                    endif
                                endfunction
                            
    1              0.000002     function! s:GetIniSetting(section, key)
                                    if !filereadable(s:config_file)
                                        return ''
                                    endif
                                    let lines = readfile(s:config_file)
                                    let currentSection = ''
                                    for line in lines
                                        let line = s:StripWhitespace(line)
                                        if matchstr(line, '^\[') != '' && matchstr(line, '\]$') != ''
                                            let currentSection = substitute(line, '^\[\(.\{-}\)\]$', '\1', '')
                                        else
                                            if currentSection == a:section
                                                let group = split(line, '=')
                                                if len(group) == 2 && s:StripWhitespace(group[0]) == a:key
                                                    return s:StripWhitespace(group[1])
                                                endif
                                            endif
                                        endif
                                    endfor
                                    return ''
                                endfunction
                            
    1              0.000002     function! s:SetIniSetting(section, key, val)
                                    let output = []
                                    let sectionFound = s:false
                                    let keyFound = s:false
                                    if filereadable(s:config_file)
                                        let lines = readfile(s:config_file)
                                        let currentSection = ''
                                        for line in lines
                                            let entry = s:StripWhitespace(line)
                                            if matchstr(entry, '^\[') != '' && matchstr(entry, '\]$') != ''
                                                if currentSection == a:section && !keyFound
                                                    let output = output + [join([a:key, a:val], '=')]
                                                    let keyFound = s:true
                                                endif
                                                let currentSection = substitute(entry, '^\[\(.\{-}\)\]$', '\1', '')
                                                let output = output + [line]
                                                if currentSection == a:section
                                                    let sectionFound = s:true
                                                endif
                                            else
                                                if currentSection == a:section
                                                    let group = split(entry, '=')
                                                    if len(group) == 2 && s:StripWhitespace(group[0]) == a:key
                                                        let output = output + [join([a:key, a:val], '=')]
                                                        let keyFound = s:true
                                                    else
                                                        let output = output + [line]
                                                    endif
                                                else
                                                    let output = output + [line]
                                                endif
                                            endif
                                        endfor
                                    endif
                                    if !sectionFound
                                        let output = output + [printf('[%s]', a:section), join([a:key, a:val], '=')]
                                    else
                                        if !keyFound
                                            let output = output + [join([a:key, a:val], '=')]
                                        endif
                                    endif
                                    call writefile(output, s:config_file)
                                endfunction
                            
    1              0.000002     function! s:GetCurrentFile()
                                    return expand("%:p")
                                endfunction
                            
    1              0.000001     function! s:EscapeArg(arg)
                                    return substitute(shellescape(a:arg), '!', '\\!', '')
                                endfunction
                            
    1              0.000002     function! s:JsonEscape(str)
                                    return substitute(a:str, '"', '\\"', 'g')
                                endfunction
                            
    1              0.000001     function! s:JoinArgs(args)
                                    let safeArgs = []
                                    for arg in a:args
                                        let safeArgs = safeArgs + [s:EscapeArg(arg)]
                                    endfor
                                    return join(safeArgs, ' ')
                                endfunction
                            
    1              0.000001     function! s:IsWindows()
                                    if has('win32') || has('win64')
                                        return s:true
                                    endif
                                    return s:false
                                endfunction
                            
    1              0.000001     function! s:CurrentTimeStr()
                                    if s:has_reltime
                                        return split(reltimestr(reltime()))[0]
                                    endif
                                    return printf('%d', localtime())
                                endfunction
                            
    1              0.000002     function! s:AppendHeartbeat(file, now, is_write, last)
                                    let file = a:file
                                    if file == ''
                                        let file = a:last.file
                                    endif
                                    if file != ''
                                        let heartbeat = {}
                                        let heartbeat.entity = file
                                        let heartbeat.time = s:CurrentTimeStr()
                                        let heartbeat.is_write = a:is_write
                                        if !empty(&syntax)
                                            let heartbeat.language = &syntax
                                        else
                                            if !empty(&filetype)
                                                let heartbeat.language = &filetype
                                            endif
                                        endif
                                        let s:heartbeats_buffer = s:heartbeats_buffer + [heartbeat]
                                        call s:SetLastHeartbeat(a:now, a:now, file)
                            
                                        if !s:buffering_heartbeats_enabled
                                            call s:SendHeartbeats()
                                        endif
                                    endif
                                endfunction
                            
    1              0.000001     function! s:SendHeartbeats()
                                    let start_time = localtime()
                                    let stdout = ''
                            
                                    if len(s:heartbeats_buffer) == 0
                                        let s:last_sent = start_time
                                        return
                                    endif
                            
                                    let heartbeat = s:heartbeats_buffer[0]
                                    let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
                                    if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
                                    else
                                        let extra_heartbeats = ''
                                    endif
                            
                                    let python_bin = g:wakatime_PythonBinary
                                    if s:IsWindows()
                                        if python_bin == 'python'
                                            let python_bin = 'pythonw'
                                        endif
                                    endif
                                    let cmd = [python_bin, '-W', 'ignore', s:cli_location]
                                    let cmd = cmd + ['--entity', heartbeat.entity]
                                    let cmd = cmd + ['--time', heartbeat.time]
                                    let cmd = cmd + ['--plugin', printf('vim/%d vim-wakatime/%s', v:version, s:VERSION)]
                                    if heartbeat.is_write
                                        let cmd = cmd + ['--write']
                                    endif
                                    if has_key(heartbeat, 'language')
                                        let cmd = cmd + ['--language', heartbeat.language]
                                    endif
                                    if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
                                    endif
                            
                                    " overwrite shell
                                    let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
                                    if !s:IsWindows()
                                        set shell=sh shellredir=>%s\ 2>&1
                                    endif
                            
                                    if s:has_async
                                        let job = job_start([&shell, &shellcmdflag, s:JoinArgs(cmd)], {
                                            \ 'stoponexit': '',
                                            \ 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
                                    elseif s:nvim_async
                                        let s:nvim_async_output = ['']
                                        let job = jobstart([&shell, &shellcmdflag, s:JoinArgs(cmd)], {
                                            \ 'detach': 1,
                                            \ 'on_stdout': function('s:NeovimAsyncOutputHandler'),
                                            \ 'on_stderr': function('s:NeovimAsyncOutputHandler'),
                                            \ 'on_exit': function('s:NeovimAsyncExitHandler')})
                                        if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
                                        endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
                                    endif
                            
                                    " restore shell
                                    let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
                                    let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
                                    if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
                                    endif
                            
                                    if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
                                    endif
                                endfunction
                            
    1              0.000002     function! s:GetHeartbeatsJson()
                                    let arr = []
                                    let loop_count = 1
                                    for heartbeat in s:heartbeats_buffer
                                        let heartbeat_str = '{"entity": "' . s:JsonEscape(heartbeat.entity) . '", '
                                        let heartbeat_str = heartbeat_str . '"timestamp": ' . s:OrderTime(heartbeat.time, loop_count) . ', '
                                        let heartbeat_str = heartbeat_str . '"is_write": '
                                        if heartbeat.is_write
                                            let heartbeat_str = heartbeat_str . 'true'
                                        else
                                            let heartbeat_str = heartbeat_str . 'false'
                                        endif
                                        if has_key(heartbeat, 'language')
                                            let heartbeat_str = heartbeat_str . ', "language": "' . s:JsonEscape(heartbeat.language) . '"'
                                        endif
                                        let heartbeat_str = heartbeat_str . '}'
                                        let arr = arr + [heartbeat_str]
                                        let loop_count = loop_count + 1
                                    endfor
                                    let s:heartbeats_buffer = []
                                    return '[' . join(arr, ',') . ']'
                                endfunction
                            
    1              0.000002     function! s:AsyncHandler(output, cmd)
                                    if s:is_debug_on && a:output != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(a:cmd) . "\n[WakaTime] Error: " . a:output
                                    endif
                                endfunction
                            
    1              0.000002     function! s:NeovimAsyncOutputHandler(job_id, output, event)
                                    let s:nvim_async_output[-1] .= a:output[0]
                                    call extend(s:nvim_async_output, a:output[1:])
                                endfunction
                            
    1              0.000002     function! s:NeovimAsyncExitHandler(job_id, exit_code, event)
                                    let output = s:StripWhitespace(join(s:nvim_async_output, "\n"))
                                    if a:exit_code == 104
                                        let output .= 'Invalid API Key'
                                    endif
                                    if (s:is_debug_on || a:exit_code == 103 || a:exit_code == 104) && (a:exit_code != 0 || output != '')
                                        echoerr printf('[WakaTime] Error %d: %s', a:exit_code, output)
                                    endif
                                endfunction
                            
    1              0.000002     function! s:OrderTime(time_str, loop_count)
                                    " Add a milisecond to a:time.
                                    " Time prevision doesn't matter, but order of heartbeats does.
                                    if !(a:time_str =~ "\.")
                                        let millisecond = printf('%d', a:loop_count)
                                        while strlen(millisecond) < 6
                                            let millisecond = '0' . millisecond
                                        endwhile
                                        return a:time_str . '.' . millisecond
                                    endif
                                    return a:time_str
                                endfunction
                            
    1              0.000002     function! s:GetLastHeartbeat()
                                    if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
                                        if !filereadable(s:data_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
                                        endif
                                        let last = readfile(s:data_file, '', 3)
                                        if len(last) == 3
                                            let s:last_heartbeat.last_heartbeat_at = last[1]
                                            let s:last_heartbeat.file = last[2]
                                        endif
                                    endif
                                    return s:last_heartbeat
                                endfunction
                            
    1              0.000002     function! s:SetLastHeartbeatInMemory(last_activity_at, last_heartbeat_at, file)
                                    let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}
                                endfunction
                            
    1              0.000002     function! s:SetLastHeartbeat(last_activity_at, last_heartbeat_at, file)
                                    call s:SetLastHeartbeatInMemory(a:last_activity_at, a:last_heartbeat_at, a:file)
                                    call writefile([substitute(printf('%d', a:last_activity_at), ',', '.', ''), substitute(printf('%d', a:last_heartbeat_at), ',', '.', ''), a:file], s:data_file)
                                endfunction
                            
    1              0.000002     function! s:EnoughTimePassed(now, last)
                                    let prev = a:last.last_heartbeat_at
                                    if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
                                    endif
                                    return s:false
                                endfunction
                            
    1              0.000001     function! s:PromptForApiKey()
                                    let api_key = s:false
                                    let api_key = s:GetIniSetting('settings', 'api_key')
                                    if api_key == ''
                                        let api_key = s:GetIniSetting('settings', 'apikey')
                                    endif
                            
                                    let api_key = inputsecret("[WakaTime] Enter your wakatime.com api key: ", api_key)
                                    call s:SetIniSetting('settings', 'api_key', api_key)
                                endfunction
                            
    1              0.000001     function! s:EnableDebugMode()
                                    call s:SetIniSetting('settings', 'debug', 'true')
                                    let s:is_debug_on = s:true
                                endfunction
                            
    1              0.000002     function! s:DisableDebugMode()
                                    call s:SetIniSetting('settings', 'debug', 'false')
                                    let s:is_debug_on = s:false
                                endfunction
                            
    1              0.000001     function! s:EnableScreenRedraw()
                                    call s:SetIniSetting('settings', 'vi_redraw', 'enabled')
                                    let s:redraw_setting = 'enabled'
                                endfunction
                            
    1              0.000002     function! s:EnableScreenRedrawAuto()
                                    call s:SetIniSetting('settings', 'vi_redraw', 'auto')
                                    let s:redraw_setting = 'auto'
                                endfunction
                            
    1              0.000001     function! s:DisableScreenRedraw()
                                    call s:SetIniSetting('settings', 'vi_redraw', 'disabled')
                                    let s:redraw_setting = 'disabled'
                                endfunction
                            
    1              0.000002     function! s:InitAndHandleActivity(is_write)
                                    call s:SetupDebugMode()
                                    call s:SetupConfigFile()
                                    call s:HandleActivity(a:is_write)
                                endfunction
                            
    1              0.000001     function! s:HandleActivity(is_write)
                                    let file = s:GetCurrentFile()
                                    if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
                                        let last = s:GetLastHeartbeat()
                                        let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
                                        if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
                                            call s:AppendHeartbeat(file, now, a:is_write, last)
                                        else
                                            if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
                                                call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
                                            endif
                                        endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
                                        if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
                                            if now - s:last_sent > s:send_buffer_seconds
                                                call s:SendHeartbeats()
                                            endif
                                        endif
                                    endif
                                endfunction
                            
                            " }}}
                            
                            
    1   0.000678   0.000005 call s:Init()
                            
                            
                            " Autocommand Events {{{
                            
    1              0.000002     augroup Wakatime
    1              0.000008         autocmd BufEnter,VimEnter * call s:InitAndHandleActivity(s:false)
    1              0.000005         autocmd CursorMoved,CursorMovedI * call s:HandleActivity(s:false)
    1              0.000002         autocmd BufWritePost * call s:HandleActivity(s:true)
    1              0.000003         if exists('##QuitPre')
    1              0.000004             autocmd QuitPre * call s:SendHeartbeats()
    1              0.000001         endif
    1              0.000001     augroup END
                            
                            " }}}
                            
                            
                            " Plugin Commands {{{
                            
    1              0.000015     :command -nargs=0 WakaTimeApiKey call s:PromptForApiKey()
    1              0.000006     :command -nargs=0 WakaTimeDebugEnable call s:EnableDebugMode()
    1              0.000006     :command -nargs=0 WakaTimeDebugDisable call s:DisableDebugMode()
    1              0.000006     :command -nargs=0 WakaTimeScreenRedrawDisable call s:DisableScreenRedraw()
    1              0.000008     :command -nargs=0 WakaTimeScreenRedrawEnable call s:EnableScreenRedraw()
    1              0.000007     :command -nargs=0 WakaTimeScreenRedrawEnableAuto call s:EnableScreenRedrawAuto()
                            
                            " }}}
                            
                            
                            " Restore wildignore option
    1              0.000002 if s:wildignore != ""
                                let &wildignore=s:wildignore
                            endif
                            
                            " Restore cpoptions
    1              0.000013 let &cpo = s:old_cpo

FUNCTION  <SNR>9_SendHeartbeats()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000020         let start_time = localtime()
    1              0.000001         let stdout = ''
                            
    1              0.000003         if len(s:heartbeats_buffer) == 0
    1              0.000002             let s:last_sent = start_time
    1              0.000001             return
                                    endif
                            
                                    let heartbeat = s:heartbeats_buffer[0]
                                    let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
                                    if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
                                    else
                                        let extra_heartbeats = ''
                                    endif
                            
                                    let python_bin = g:wakatime_PythonBinary
                                    if s:IsWindows()
                                        if python_bin == 'python'
                                            let python_bin = 'pythonw'
                                        endif
                                    endif
                                    let cmd = [python_bin, '-W', 'ignore', s:cli_location]
                                    let cmd = cmd + ['--entity', heartbeat.entity]
                                    let cmd = cmd + ['--time', heartbeat.time]
                                    let cmd = cmd + ['--plugin', printf('vim/%d vim-wakatime/%s', v:version, s:VERSION)]
                                    if heartbeat.is_write
                                        let cmd = cmd + ['--write']
                                    endif
                                    if has_key(heartbeat, 'language')
                                        let cmd = cmd + ['--language', heartbeat.language]
                                    endif
                                    if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
                                    endif
                            
                                    " overwrite shell
                                    let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
                                    if !s:IsWindows()
                                        set shell=sh shellredir=>%s\ 2>&1
                                    endif
                            
                                    if s:has_async
                                        let job = job_start([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
                                    elseif s:nvim_async
                                        let s:nvim_async_output = ['']
                                        let job = jobstart([&shell, &shellcmdflag, s:JoinArgs(cmd)], { 'detach': 1, 'on_stdout': function('s:NeovimAsyncOutputHandler'), 'on_stderr': function('s:NeovimAsyncOutputHandler'), 'on_exit': function('s:NeovimAsyncExitHandler')})
                                        if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
                                        endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
                                    endif
                            
                                    " restore shell
                                    let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
                                    let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
                                    if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
                                    endif
                            
                                    if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
                                    endif

FUNCTION  <SNR>9_InitAndHandleActivity()
Called 2 times
Total time:   0.001389
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000400   0.000007         call s:SetupDebugMode()
    2   0.000626   0.000005         call s:SetupConfigFile()
    2   0.000362   0.000007         call s:HandleActivity(a:is_write)

FUNCTION  <SNR>9_AsyncHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    if s:is_debug_on && a:output != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(a:cmd) . "\n[WakaTime] Error: " . a:output
                                    endif

FUNCTION  <SNR>9_OrderTime()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    " Add a milisecond to a:time.
                                    " Time prevision doesn't matter, but order of heartbeats does.
                                    if !(a:time_str =~ "\.")
                                        let millisecond = printf('%d', a:loop_count)
                                        while strlen(millisecond) < 6
                                            let millisecond = '0' . millisecond
                                        endwhile
                                        return a:time_str . '.' . millisecond
                                    endif
                                    return a:time_str

FUNCTION  <SNR>9_SetLastHeartbeat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetLastHeartbeatInMemory(a:last_activity_at, a:last_heartbeat_at, a:file)
                                    call writefile([substitute(printf('%d', a:last_activity_at), ',', '.', ''), substitute(printf('%d', a:last_heartbeat_at), ',', '.', ''), a:file], s:data_file)

FUNCTION  <SNR>9_SetupDebugMode()
Called 2 times
Total time:   0.000393
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000003         if !s:debug_mode_already_setup
    1   0.000377   0.000005             if s:GetIniSetting('settings', 'debug') == 'true'
                                            let s:is_debug_on = s:true
                                        else
    1              0.000002                 let s:is_debug_on = s:false
    1              0.000001             endif
    1              0.000002             let s:debug_mode_already_setup = s:true
    1              0.000000         endif

FUNCTION  <SNR>9_EnableScreenRedrawAuto()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetIniSetting('settings', 'vi_redraw', 'auto')
                                    let s:redraw_setting = 'auto'

FUNCTION  <SNR>9_GetHeartbeatsJson()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let arr = []
                                    let loop_count = 1
                                    for heartbeat in s:heartbeats_buffer
                                        let heartbeat_str = '{"entity": "' . s:JsonEscape(heartbeat.entity) . '", '
                                        let heartbeat_str = heartbeat_str . '"timestamp": ' . s:OrderTime(heartbeat.time, loop_count) . ', '
                                        let heartbeat_str = heartbeat_str . '"is_write": '
                                        if heartbeat.is_write
                                            let heartbeat_str = heartbeat_str . 'true'
                                        else
                                            let heartbeat_str = heartbeat_str . 'false'
                                        endif
                                        if has_key(heartbeat, 'language')
                                            let heartbeat_str = heartbeat_str . ', "language": "' . s:JsonEscape(heartbeat.language) . '"'
                                        endif
                                        let heartbeat_str = heartbeat_str . '}'
                                        let arr = arr + [heartbeat_str]
                                        let loop_count = loop_count + 1
                                    endfor
                                    let s:heartbeats_buffer = []
                                    return '[' . join(arr, ',') . ']'

FUNCTION  <SNR>9_CurrentTimeStr()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    if s:has_reltime
                                        return split(reltimestr(reltime()))[0]
                                    endif
                                    return printf('%d', localtime())

FUNCTION  <SNR>9_AppendHeartbeat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let file = a:file
                                    if file == ''
                                        let file = a:last.file
                                    endif
                                    if file != ''
                                        let heartbeat = {}
                                        let heartbeat.entity = file
                                        let heartbeat.time = s:CurrentTimeStr()
                                        let heartbeat.is_write = a:is_write
                                        if !empty(&syntax)
                                            let heartbeat.language = &syntax
                                        else
                                            if !empty(&filetype)
                                                let heartbeat.language = &filetype
                                            endif
                                        endif
                                        let s:heartbeats_buffer = s:heartbeats_buffer + [heartbeat]
                                        call s:SetLastHeartbeat(a:now, a:now, file)
                            
                                        if !s:buffering_heartbeats_enabled
                                            call s:SendHeartbeats()
                                        endif
                                    endif

FUNCTION  <SNR>9_EnoughTimePassed()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let prev = a:last.last_heartbeat_at
                                    if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
                                    endif
                                    return s:false

FUNCTION  <SNR>9_IsWindows()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    if has('win32') || has('win64')
                                        return s:true
                                    endif
                                    return s:false

FUNCTION  <SNR>9_DisableScreenRedraw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetIniSetting('settings', 'vi_redraw', 'disabled')
                                    let s:redraw_setting = 'disabled'

FUNCTION  <SNR>9_EnableScreenRedraw()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetIniSetting('settings', 'vi_redraw', 'enabled')
                                    let s:redraw_setting = 'enabled'

FUNCTION  <SNR>9_Init()
Called 1 time
Total time:   0.000673
 Self time:   0.000174

count  total (s)   self (s)
                            
                                    " For backwards compatibility, rename wakatime.conf to wakatime.cfg
    1              0.000124         if !filereadable(s:config_file)
                                        if filereadable(expand("$HOME/.wakatime"))
                                            exec "silent !mv" expand("$HOME/.wakatime") expand("$HOME/.wakatime.conf")
                                        endif
                                        if filereadable(expand("$HOME/.wakatime.conf"))
                                            if !filereadable(s:config_file)
                                                let contents = ['[settings]'] + readfile(expand("$HOME/.wakatime.conf"), '')
                                                call writefile(contents, s:config_file)
                                                call delete(expand("$HOME/.wakatime.conf"))
                                            endif
                                        endif
                                    endif
                            
                                    " Set default python binary location
    1              0.000002         if !exists("g:wakatime_PythonBinary")
    1              0.000002             let g:wakatime_PythonBinary = 'python'
    1              0.000002         endif
                            
                                    " Set default heartbeat frequency in minutes
    1              0.000002         if !exists("g:wakatime_HeartbeatFrequency")
    1              0.000002             let g:wakatime_HeartbeatFrequency = 2
    1              0.000000         endif
                            
                                    " Get legacy g:wakatime_ScreenRedraw setting
    1              0.000001         let s:redraw_setting = 'auto'
    1              0.000002         if exists("g:wakatime_ScreenRedraw") && g:wakatime_ScreenRedraw
                                        let s:redraw_setting = 'enabled'
                                    endif
                            
                                    " Get redraw setting from wakatime.cfg file
    1   0.000504   0.000005         if s:GetIniSetting('settings', 'vi_redraw') != ''
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'enabled'
                                            let s:redraw_setting = 'enabled'
                                        endif
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'auto'
                                            let s:redraw_setting = 'auto'
                                        endif
                                        if s:GetIniSetting('settings', 'vi_redraw') == 'disabled'
                                            let s:redraw_setting = 'disabled'
                                        endif
                                    endif
                            
                                    " Buffering heartbeats disabled in Windows, unless have async support
    1              0.000003         let s:buffering_heartbeats_enabled = s:has_async || s:nvim_async || !s:IsWindows()
                            

FUNCTION  <SNR>9_NeovimAsyncExitHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let output = s:StripWhitespace(join(s:nvim_async_output, "\n"))
                                    if a:exit_code == 104
                                        let output .= 'Invalid API Key'
                                    endif
                                    if (s:is_debug_on || a:exit_code == 103 || a:exit_code == 104) && (a:exit_code != 0 || output != '')
                                        echoerr printf('[WakaTime] Error %d: %s', a:exit_code, output)
                                    endif

FUNCTION  <SNR>9_GetLastHeartbeat()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
                                        if !filereadable(s:data_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
                                        endif
                                        let last = readfile(s:data_file, '', 3)
                                        if len(last) == 3
                                            let s:last_heartbeat.last_heartbeat_at = last[1]
                                            let s:last_heartbeat.file = last[2]
                                        endif
                                    endif
                                    return s:last_heartbeat

FUNCTION  <SNR>9_GetCurrentFile()
Called 3 times
Total time:   0.000463
 Self time:   0.000463

count  total (s)   self (s)
    3              0.000462         return expand("%:p")

FUNCTION  <SNR>9_EnableDebugMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetIniSetting('settings', 'debug', 'true')
                                    let s:is_debug_on = s:true

FUNCTION  <SNR>9_DisableDebugMode()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    call s:SetIniSetting('settings', 'debug', 'false')
                                    let s:is_debug_on = s:false

FUNCTION  <SNR>9_StripWhitespace()
Called 32 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   32              0.000192         return substitute(a:str, '^\s*\(.\{-}\)\s*$', '\1', '')

FUNCTION  <SNR>9_SetupConfigFile()
Called 2 times
Total time:   0.000620
 Self time:   0.000188

count  total (s)   self (s)
    2              0.000002         if !s:config_file_already_setup
                            
                                        " Create config file if does not exist
    1              0.000123             if !filereadable(s:config_file)
                                            call writefile(s:default_configs, s:config_file)
                                        endif
                            
                                        " Make sure config file has api_key
    1              0.000002             let found_api_key = s:false
    1   0.000452   0.000020             if s:GetIniSetting('settings', 'api_key') != '' || s:GetIniSetting('settings', 'apikey') != ''
    1              0.000001                 let found_api_key = s:true
    1              0.000000             endif
    1              0.000001             if !found_api_key
                                            call s:PromptForApiKey()
                                            echo "[WakaTime] Setup complete! Visit https://wakatime.com to view your coding activity."
                                        endif
                            
    1              0.000002             let s:config_file_already_setup = s:true
    1              0.000000         endif

FUNCTION  <SNR>9_JsonEscape()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    return substitute(a:str, '"', '\\"', 'g')

FUNCTION  <SNR>9_GetIniSetting()
Called 3 times
Total time:   0.001303
 Self time:   0.001104

count  total (s)   self (s)
    3              0.000385         if !filereadable(s:config_file)
                                        return ''
                                    endif
    3              0.000255         let lines = readfile(s:config_file)
    3              0.000005         let currentSection = ''
   24              0.000019         for line in lines
   23   0.000218   0.000064             let line = s:StripWhitespace(line)
   23              0.000082             if matchstr(line, '^\[') != '' && matchstr(line, '\]$') != ''
    6              0.000034                 let currentSection = substitute(line, '^\[\(.\{-}\)\]$', '\1', '')
    6              0.000003             else
   17              0.000017                 if currentSection == a:section
   17              0.000041                     let group = split(line, '=')
   17   0.000081   0.000048                     if len(group) == 2 && s:StripWhitespace(group[0]) == a:key
    2   0.000017   0.000006                         return s:StripWhitespace(group[1])
                                                endif
   15              0.000006                 endif
   15              0.000005             endif
   21              0.000009         endfor
    1              0.000001         return ''

FUNCTION  <SNR>9_JoinArgs()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let safeArgs = []
                                    for arg in a:args
                                        let safeArgs = safeArgs + [s:EscapeArg(arg)]
                                    endfor
                                    return join(safeArgs, ' ')

FUNCTION  <SNR>9_SetIniSetting()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let output = []
                                    let sectionFound = s:false
                                    let keyFound = s:false
                                    if filereadable(s:config_file)
                                        let lines = readfile(s:config_file)
                                        let currentSection = ''
                                        for line in lines
                                            let entry = s:StripWhitespace(line)
                                            if matchstr(entry, '^\[') != '' && matchstr(entry, '\]$') != ''
                                                if currentSection == a:section && !keyFound
                                                    let output = output + [join([a:key, a:val], '=')]
                                                    let keyFound = s:true
                                                endif
                                                let currentSection = substitute(entry, '^\[\(.\{-}\)\]$', '\1', '')
                                                let output = output + [line]
                                                if currentSection == a:section
                                                    let sectionFound = s:true
                                                endif
                                            else
                                                if currentSection == a:section
                                                    let group = split(entry, '=')
                                                    if len(group) == 2 && s:StripWhitespace(group[0]) == a:key
                                                        let output = output + [join([a:key, a:val], '=')]
                                                        let keyFound = s:true
                                                    else
                                                        let output = output + [line]
                                                    endif
                                                else
                                                    let output = output + [line]
                                                endif
                                            endif
                                        endfor
                                    endif
                                    if !sectionFound
                                        let output = output + [printf('[%s]', a:section), join([a:key, a:val], '=')]
                                    else
                                        if !keyFound
                                            let output = output + [join([a:key, a:val], '=')]
                                        endif
                                    endif
                                    call writefile(output, s:config_file)

FUNCTION  <SNR>9_PromptForApiKey()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let api_key = s:false
                                    let api_key = s:GetIniSetting('settings', 'api_key')
                                    if api_key == ''
                                        let api_key = s:GetIniSetting('settings', 'apikey')
                                    endif
                            
                                    let api_key = inputsecret("[WakaTime] Enter your wakatime.com api key: ", api_key)
                                    call s:SetIniSetting('settings', 'api_key', api_key)

FUNCTION  <SNR>9_SetLastHeartbeatInMemory()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}

FUNCTION  <SNR>9_EscapeArg()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    return substitute(shellescape(a:arg), '!', '\\!', '')

FUNCTION  <SNR>9_NeovimAsyncOutputHandler()
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                    let s:nvim_async_output[-1] .= a:output[0]
                                    call extend(s:nvim_async_output, a:output[1:])

FUNCTION  <SNR>9_HandleActivity()
Called 3 times
Total time:   0.000544
 Self time:   0.000081

count  total (s)   self (s)
    3   0.000474   0.000011         let file = s:GetCurrentFile()
    3              0.000009         if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
                                        let last = s:GetLastHeartbeat()
                                        let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
                                        if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
                                            call s:AppendHeartbeat(file, now, a:is_write, last)
                                        else
                                            if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
                                                call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
                                            endif
                                        endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
                                        if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
                                            if now - s:last_sent > s:send_buffer_seconds
                                                call s:SendHeartbeats()
                                            endif
                                        endif
                                    endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.001389   0.000021  <SNR>9_InitAndHandleActivity()
    3   0.001303   0.001104  <SNR>9_GetIniSetting()
    1   0.000673   0.000174  <SNR>9_Init()
    2   0.000620   0.000188  <SNR>9_SetupConfigFile()
    3   0.000544   0.000081  <SNR>9_HandleActivity()
    3   0.000463             <SNR>9_GetCurrentFile()
    2   0.000393   0.000021  <SNR>9_SetupDebugMode()
   32   0.000199             <SNR>9_StripWhitespace()
    1   0.000042             <SNR>9_SendHeartbeats()
                             <SNR>9_AppendHeartbeat()
                             <SNR>9_EnoughTimePassed()
                             <SNR>9_IsWindows()
                             <SNR>9_DisableScreenRedraw()
                             <SNR>9_EnableScreenRedraw()
                             <SNR>9_CurrentTimeStr()
                             <SNR>9_GetHeartbeatsJson()
                             <SNR>9_GetLastHeartbeat()
                             <SNR>9_EnableScreenRedrawAuto()
                             <SNR>9_EnableDebugMode()
                             <SNR>9_DisableDebugMode()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    3   0.001303   0.001104  <SNR>9_GetIniSetting()
    3              0.000463  <SNR>9_GetCurrentFile()
   32              0.000199  <SNR>9_StripWhitespace()
    2   0.000620   0.000188  <SNR>9_SetupConfigFile()
    1   0.000673   0.000174  <SNR>9_Init()
    3   0.000544   0.000081  <SNR>9_HandleActivity()
    1              0.000042  <SNR>9_SendHeartbeats()
    2   0.000393   0.000021  <SNR>9_SetupDebugMode()
    2   0.001389   0.000021  <SNR>9_InitAndHandleActivity()
                             <SNR>9_AppendHeartbeat()
                             <SNR>9_EnoughTimePassed()
                             <SNR>9_IsWindows()
                             <SNR>9_DisableScreenRedraw()
                             <SNR>9_EnableScreenRedraw()
                             <SNR>9_CurrentTimeStr()
                             <SNR>9_GetHeartbeatsJson()
                             <SNR>9_GetLastHeartbeat()
                             <SNR>9_EnableScreenRedrawAuto()
                             <SNR>9_EnableDebugMode()
                             <SNR>9_DisableDebugMode()

