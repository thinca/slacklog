[{"type":"message","user":"UPZHKAM7W","text":"```\niconv({expr}, {from}, {to})                             *iconv()*\n                文字列{expr}をエンコーディング{from}からエンコーディング{to}に\n                変換した文字列を返す。\n                変換が完全に失敗したときは空文字列を返す。一部の文字が変換でき\n                なかった場合、その文字は \"?\" に置き換わる。\n                エンコーディング名はライブラリ関数iconv()が受け付けるものなら\n                なんでもよい。\":!man 3 iconv\" を参照。\n                ほとんどの変換は、Vimが|+iconv|機能つきでコンパイルされている\n                ときのみ利用可能。|+iconv|つきでないときもUTF-8からlatin1への\n                変換とその逆は行える。\n                オプション 'encoding' の値に関係なく、特殊な文字を含むメッセー\n                ジを表示するために使える。UTF-8でエンコードされたメッセージを\n                表示するには次のようにする:  \n                        echo iconv(utf8_str, \"utf-8\", \u0026amp;enc)\n                Note Vimは全てのUnicodeエンコーディングに対してUTF-8を使う。\n                UCS-2との変換を行おうとしても、自動的にUTF-8との変換に変更され\n                る。いずれにせよ、UCS-2はNULバイトを含むため、文字列にUCS-2を\n                使うことはできない。\n \n                |method| としても使用できる:  \n                        GetText()-\u0026gt;iconv('latin1', 'utf-8')\n```","ts":"1603800846.277900","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"6D9FD359-C769-44EB-AD3A-EEBB606B52A6","type":"message","user":"UBQ2H65JQ","text":":h iconv()","ts":"1603800845.277800","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"EAXU"}]},{"type":"message","user":"UPZHKAM7W","text":"```\nVIM - Vi IMproved 8.2 (2019 Dec 12, compiled Oct 21 2020 15:12:38)\nIncluded patches: 1-1880\nCompiled by Docker \u003chttps://github.com/thinca/dockerfile-vim\u003e\nHuge version without GUI.  Features included (+) or not (-):\n+acl               -farsi             +mouse_sgr         +tag_binary\n+arabic            +file_in_path      -mouse_sysmouse    -tag_old_static\n+autocmd           +find_in_path      +mouse_urxvt       -tag_any_white\n+autochdir         +float             +mouse_xterm       -tcl\n-autoservername    +folding           +multi_byte        +termguicolors\n-balloon_eval      -footer            +multi_lang        +terminal\n+balloon_eval_term +fork()            -mzscheme          +terminfo\n-browse            +gettext           +netbeans_intg     +termresponse\n++builtin_terms    -hangul_input      +num64             +textobjects\n+byte_offset       +iconv             +packages          +textprop\n+channel           +insert_expand     +path_extra        +timers\n+cindent           +ipv6              -perl              +title\n-clientserver      +job               +persistent_undo   -toolbar\n-clipboard         +jumplist          +popupwin          +user_commands\n+cmdline_compl     +keymap            +postscript        +vartabs\n+cmdline_hist      +lambda            +printer           +vertsplit\n+cmdline_info      +langmap           +profile           +virtualedit\n+comments          +libcall           -python            +visual\n+conceal           +linebreak         -python3           +visualextra\n+cryptv            +lispindent        +quickfix          +viminfo\n+cscope            +listcmds          +reltime           +vreplace\n+cursorbind        +localmap          +rightleft         +wildignore\n+cursorshape       -lua               -ruby              +wildmenu\n+dialog_con        +menu              +scrollbind        +windows\n+diff              +mksession         +signs             +writebackup\n+digraphs          +modify_fname      +smartindent       -X11\n-dnd               +mouse             -sound             -xfontset\n-ebcdic            -mouseshape        +spell             -xim\n+emacs_tags        +mouse_dec         +startuptime       -xpm\n+eval              -mouse_gpm         +statusline        -xsmp\n+ex_extra          -mouse_jsbterm     -sun_workshop      -xterm_clipboard\n+extra_search      +mouse_netterm     +syntax            -xterm_save\n   system vimrc file: \"$VIM/vimrc\"\n     user vimrc file: \"$HOME/.vimrc\"\n 2nd user vimrc file: \"~/.vim/vimrc\"\n      user exrc file: \"$HOME/.exrc\"\n       defaults file: \"$VIMRUNTIME/defaults.vim\"\n  fall-back for $VIM: \"/usr/local/share/vim\"\nCompilation: gcc -c -I. -Iproto -DHAVE_CONFIG_H     -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1       \nLinking: gcc   -L/usr/local/lib -Wl,--as-needed -o vim        -lm -lncurses  -lacl -lintl           \n```","ts":"1603800089.277500","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"4c835b07-2260-4d5f-bf7f-27c3b574f3db","type":"message","user":"U9S4G0LJW","text":":version","ts":"1603800088.277400","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"MzZt"}]},{"type":"message","user":"UPZHKAM7W","text":"```\nVim(gui):E25: GUI cannot be used: Not enabled at compile time: gui\n```","ts":"1603800050.277100","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"002e7f1b-6758-4f93-804b-f92e5af39a47","type":"message","user":"U9S4G0LJW","text":":gui","ts":"1603800049.277000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"fYPN"}]},{"type":"message","user":"UPZHKAM7W","text":"```\njob_start({command} [, {options}])                      *job_start()*\n                ジョブを開始し、ジョブオブジェクトを返す。|system()|と|:!cmd|\n                とは異なり、これはジョブが終了するのを待つことはない。\n                端末ウィンドウ内でジョブを開始する方法については\n                |term_start()| を参照。\n \n                ジョブが起動に失敗した場合、返されたジョブオブジェクトの\n                |job_status()| は \"fail\" となり、どのコールバックも呼び出され\n                ない。\n \n                {command}は文字列にできる。これはMS-Windowsで最も効果的である。\n                Unixでは、それはexecvp()に渡すために空白で区切られたパーツに分\n                割される。二重引用符で囲まれた引数には空白を含められる。\n \n                {command}はリストにでき、最初の項目は実行可能ファイルであり、\n                残りの項目は引数である。すべての項目は文字列に変換される。これ\n                はUnixで最も効果的である。\n \n                MS-Windowsでは、|job_start()|はGUIアプリケーションを隠す。それ\n                を表示したい場合は、|:!start|を代わりに使用すること。\n \n                コマンドはシェルではなく直接実行され、'shell' オプションは使用\n                されない。シェルを使用するには:  \n        let job = job_start([\"/bin/sh\", \"-c\", \"echo hello\"])\n                または:  \n        let job = job_start('/bin/sh -c \"echo hello\"')\n                これは2つのプロセス、シェルとそれが実行するコマンドを開始する\n                ことに注意すること。これを望まない場合は、\"exec\" シェルコマン\n                ドを使用する。\n \n                Unixでは$PATHは、コマンドにスラッシュが含まれていない場合にの\n                み実行可能ファイルを検索するために使用される。\n \n                ジョブはVimと同じ端末を使用する。ジョブがstdinを読む場合、ジョ\n                ブとVimが入力を奪い合うことになるのでうまく動作しない。問題を\n                避けるためにstdinとstdoutをリダイレクトする:  \n        let job = job_start(['sh', '-c', \"myserver \u0026lt;/dev/null \u0026gt;/dev/null\"])\n \n                返されたジョブオブジェクトを使用して、|job_status()|でステータ\n                スを取得し、|job_stop()|でジョブを停止することができる。\n \n                Note: ジョブオブジェクトは、それを参照するものがない場合削除さ\n                れる。これは stdin および stdout を閉じ、エラーによるジョブの\n                失敗を引き起こす。これを回避するにはジョブへの参照を維持する。\n                したがって、以下の代わりに:  \n        call job_start('my-command')\n                このようにし:  \n        let myjob = job_start('my-command')\n                さらに、ジョブが必要なくなったとき、もしくは (開始時にメッセー\n                ジが表示されたときのように) ジョブが失敗した後に、\"myjob\" を\n                unlet する。関数のローカル変数は、関数が終了すると消滅すること\n                に注意すること。必要であればスクリプトローカルな変数を使用する\n                ことができる:  \n        let s:myjob = job_start('my-command')\n \n                {options}は辞書でなければならない。多くのオプション項目を含め\n                ることができる。|job-options|参照。\n \n                |method| としても使用できる:  \n                        BuildCommand()-\u0026gt;job_start()\n```","ts":"1603795616.276800","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"57443C98-0EEF-427F-B592-2CEB0D7F0312","type":"message","user":"UBQ2H65JQ","text":":h job_start()","ts":"1603795615.276700","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"AK1jM"}]},{"type":"message","user":"UPZHKAM7W","text":"```\n\"channel.txt\" [readonly] 1321L, 50170B\n```","ts":"1603795591.276600","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"6E6F1957-769D-4104-B1FF-EEFE56A83575","type":"message","user":"UBQ2H65JQ","text":": h job_start()","ts":"1603795590.276500","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"8YyGA"}]},{"type":"message","user":"UPZHKAM7W","text":"```\nterm_start({cmd} [, {options}])                 *term_start()*\n                端末ウィンドウを開き、その中で {cmd} を実行する。\n \n                {cmd} は |job_start()| と同じような文字列もしくはリストである。\n                ジョブを開始せずに端末ウィンドウを開くには、文字列 \"NONE\" を使\n                用することができ、端末の疑似端末は gdb のようなコマンドで使用\n                することができる。\n \n                端末ウィンドウのバッファ番号を返す。{cmd} が実行できない場合、\n                ウィンドウが開いてエラーメッセージを表示する。\n                ウィンドウを開くのに失敗すると 0 を返す。\n \n                {options} は |job_start()| で使用されるものと似ている。\n                |job-options| を参照。しかしながらすべてのオプションが使えるわ\n                けではない。サポートされているものは以下のとおり:\n                   すべての timeout オプション\n                   \"stoponexit\", \"cwd\", \"env\"\n                   \"callback\", \"out_cb\", \"err_cb\", \"exit_cb\", \"close_cb\"\n                   \"in_io\", \"in_top\", \"in_bot\", \"in_name\", \"in_buf\"\n                   \"out_io\", \"out_name\", \"out_buf\", \"out_modifiable\", \"out_msg\"\n                   \"err_io\", \"err_name\", \"err_buf\", \"err_modifiable\", \"err_msg\"\n                しなかしながら、少なくとも stdin、stdout もしくは stderr のう\n                ち 1 つは端末に接続されていなければならない。I/O が端末に接続\n                されているとき、その部分のコールバック機能は使用されない。\n \n                追加のオプションは以下のとおり:\n                   \"term_name\"       (コマンド名の代わりに使用される)バッファ\n                                     名に使用する名前。\n                   \"term_rows\"       ('termwinsize' の代わりに使用される) 端末\n                                     の垂直サイズ\n                   \"term_cols\"       ('termwinsize' の代わりに使用される) 端末\n                                     の水平サイズ\n                   \"vertical\"        ウィンドウを垂直に分割する。Note: 他のウィ\n                                     ンドウの位置は、|:belowright| のようなコマ\n                                     ンド修飾子によって決められる。\n                   \"curwin\"          ウィンドウを分割せず現在のウィンドウを使\n                                     用する、現在のバッファが放棄 (|abandon|)\n                                     不可の場合は失敗する\n                   \"hidden\"          ウィンドウを開かない\n                   \"norestore\"       端末ウィンドウをセッションファイルに加え\n                                     ない\n                   \"term_kill\"       端末ウィンドウを閉じようとしているときに\n                                     何をするか、|term_setkill()| を参照\n                   \"term_finish\"     ジョブが終了したときに何をするか:\n                                        \"close\": ウィンドウを閉じる\n                                        \"open\": 必要ならばウィンドウを開く\n                                     Note: \"open\" は割り込み的に発生する。\n                                     |term++close| および |term++open|を参照。\n                   \"term_opencmd\"    \"term_finish\" が \"open\" のときにウィンド\n                                     ウを開くために使用されるコマンド: バッファ\n                                     番号が入る \"%d\" を含む必要がある、例\n                                     \"10split|buffer %d\": 指定されていない場合\n                                     は \"botright sbuf %d\" が使用される\n                   \"term_highlight\"  \"Terminal\" の代わりにハイライトグループと\n                                     して使える\n                   \"eof_chars\"       すべてのバッファ行が書き込まれた後に端末\n                                     に送られるテキスト。設定されていないとき\n                                     は MS-Windows では CTRL-D が使用される。\n                                     Pythonでは CTRL-Z もしくは \"exit()\" を使\n                                     用する。シェルでは \"exit\" を使用する。常\n                                     に CR が追加される。\n                                     \"exit\".  A CR is always added.\n                   \"ansi_colors\"     GUI カラーモードで使われる ANSI パレット\n                                     を定義する 16 個のカラー名もしくは 16 進\n                                     数コード。|g:terminal_ansi_colors| を参\n                                     照。\n                   \"tty_type\"        (MS-Windowsのみ): 使用する pty を指定す\n                                     る。値については 'termwintype' を参照。\n                   \"term_api\"        |terminal-api| 機能の関数名プリフィック\n                                     ス。|term_setapi()| を参照。\n \n                |method| としても使用できる:  \n                        GetCommand()-\u0026gt;term_start()\n```","ts":"1603795537.276100","bot_id":"BPM858KEE","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":null},{"client_msg_id":"AAADE9AA-BD97-4F52-AF46-8B1C2F2F7407","type":"message","user":"UBQ2H65JQ","text":":h term_start()","ts":"1603795536.276000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"WXH"}]}]
