[{"client_msg_id":"9402f3cd-e91b-4bcc-be95-7db64e746099","type":"message","user":"U03C71D7H","text":"@ Milly 現状、タイムアウト時の処理は Promise を解決する前、setTimeout に渡した関数で直接やってるんですよね。大元の Promise の処理は外部がやってて、そちらではタイムアウト時の処理について意識したくなかったので","ts":"1607780701.010100","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"+9m"}]},{"client_msg_id":"92339aa6-4be2-4919-81fb-0bc62a54e7e5","type":"message","user":"U03C71D7H","text":"なるほど \u0026gt;思い違い\n\nやっぱ面倒ですねぇ","ts":"1607780499.008000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"+P2"}]},{"client_msg_id":"decee49d-134d-47c5-9777-c331bc703bf2","type":"message","user":"UAZ33BKV2","text":"いやそれだと正規処理が実行されたときにタイムアウト処理をキャンセルする要件とは関係がないような...","ts":"1607779201.007600","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"Kzrj/"}]},{"client_msg_id":"22eeb7c6-30ec-45b3-a5b5-ee4c02dbb21e","type":"message","user":"UP6PA1UBE","text":"timeout の Promise の resolve (か reject) から `'timeout'` とかを引数で投げればいいのでは、という意味","ts":"1607778732.006800","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"0MA6u"}]},{"client_msg_id":"1ec7a57f-6d39-49a7-8576-613eae6ab3d0","type":"message","user":"UAZ33BKV2","text":"\u003chttps://qiita.com/KuwaK/items/0193cddf9d96fdc53728\u003e\nこんなんあるし、なんかしらフラグやらを差し込むとかしないとだめなんでしょうね...","ts":"1607777950.005300","attachments":[{"fallback":"Qiita: キャンセル可能でPromiseなsetTimeout()を作る - Qiita","id":1,"title":"キャンセル可能でPromiseなsetTimeout()を作る - Qiita","title_link":"https://qiita.com/KuwaK/items/0193cddf9d96fdc53728","text":"async/awaitを使ってきちんと非同期処理の実行順序を制御するためには、async関数内で使用するsetTimeout()のようなコールバック関数をPromise化する必要があります。 で、普通にPromise化する分にはいい...","image_url":"https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-1.2.2\u0026w=1200\u0026mark=https%3A%2F%2Fqiita-user-contents.imgix.net%2F~text%3Fixlib%3Drb-1.2.2%26w%3D840%26h%3D380%26txt%3D%25E3%2582%25AD%25E3%2583%25A3%25E3%2583%25B3%25E3%2582%25BB%25E3%2583%25AB%25E5%258F%25AF%25E8%2583%25BD%25E3%2581%25A7Promise%25E3%2581%25AAsetTimeout%2528%2529%25E3%2582%2592%25E4%25BD%259C%25E3%2582%258B%26txt-color%3D%2523333%26txt-font%3DHiragino%2520Sans%2520W6%26txt-size%3D54%26txt-clip%3Dellipsis%26txt-align%3Dcenter%252Cmiddle%26s%3D7ff1a5ddc10d230205a743cb138b4c3b\u0026mark-align=center%2Cmiddle\u0026blend=https%3A%2F%2Fqiita-user-contents.imgix.net%2F~text%3Fixlib%3Drb-1.2.2%26w%3D840%26h%3D500%26txt%3D%2540KuwaK%26txt-color%3D%2523333%26txt-font%3DHiragino%2520Sans%2520W6%26txt-size%3D45%26txt-align%3Dright%252Cbottom%26s%3D7d2d2e77d83a1b02a08f7ba2b68b6768\u0026blend-align=center%2Cmiddle\u0026blend-mode=normal\u0026s=4fb3d4f23988b74967f038d9b15672b5","blocks":null,"service_name":"Qiita","service_icon":"https://cdn.qiita.com/assets/favicons/public/apple-touch-icon-ec5ba42a24ae923f16825592efdc356f.png","from_url":"https://qiita.com/KuwaK/items/0193cddf9d96fdc53728","original_url":"https://qiita.com/KuwaK/items/0193cddf9d96fdc53728"}],"team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"qm+yF"}]},{"client_msg_id":"01a2a252-8d67-46fb-ba78-d44d2b10a770","type":"message","user":"UAZ33BKV2","text":"あー、すみません他と思い違いしてAPIあった気でいたかも...じゃあ無理ですねえ","ts":"1607777740.004800","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"kgi"}]},{"client_msg_id":"e0e2b6f9-f094-4bfc-ba60-6a1a154ebb3b","type":"message","user":"U03C71D7H","text":"Promise 自体からその Promise の状態を取る API はないと思うんですが、どうやるんでしょう?","ts":"1607777522.004300","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"bY4"}]},{"client_msg_id":"dff3af7e-f99f-4c71-a158-960fbf873113","type":"message","user":"UAZ33BKV2","text":"フラグといえばフラグですが、フラグという変数とか外部のなにかじゃなくて、Promiseそのものでのつもりでした。\n大差はないか...","ts":"1607777398.003700","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"n3qD"}]},{"client_msg_id":"5982ca29-64d2-4ee0-93ac-e4c57a83c3d7","type":"message","user":"U03C71D7H","text":"うーん、あとは例外の種類を変えるようにしてタイムアウト時の処理はタイムアウト例外を catch した時に実行する、とかかなぁ\nJS の例外、型指定して catch できないのでめんどいんだよな。あんまり使いたくない","ts":"1607777328.002600","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"uBCUR"}]},{"client_msg_id":"304b8577-eb6b-4129-bf58-2fa15c6d9fbd","type":"message","user":"U03C71D7H","text":"\u0026gt; タイムアウト処理が正常処理のPromiseも抱えるようにしておいて、タイムアウト処理内で完了してるかチェックするように作れたりしませんかね? 邪道かな...?\nこれってつまり私が言ったフラグ立てておくって話ですよね…? なにか違う?","ts":"1607775167.001400","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"yro"}]},{"client_msg_id":"8cc64e86-6800-4207-88d2-1f70a63ec8f1","type":"message","user":"UAZ33BKV2","text":"サンプル書ける人プリーズ(自分ももやっとこんなかなを言っただけなので)","ts":"1607775028.000900","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"y9M0"}]},{"client_msg_id":"81217849-60be-4f4e-940b-ae5697039e11","type":"message","user":"U03C71D7H","text":"どういうことかよくわからない…","ts":"1607774935.498600","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"NTuB1"}]},{"client_msg_id":"bbbecdee-daaa-44fc-a4f9-d68e73233827","type":"message","user":"UAZ33BKV2","text":"そうですね、処理を分解してそういう風にするのがいいか","ts":"1607774420.498300","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"MBKjB"}]},{"client_msg_id":"8808d2a1-854e-407b-86f1-82ed550b7730","type":"message","user":"UP6PA1UBE","text":"メインの処理を race の then で処理すれば timeout かどうか判定できますね","ts":"1607774360.498000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"4NfA"}]},{"client_msg_id":"4abbc55b-0aff-43e0-b4df-abe5407826cf","type":"message","user":"UAZ33BKV2","text":"タイムアウト処理が正常処理のPromiseも抱えるようにしておいて、タイムアウト処理内で完了してるかチェックするように作れたりしませんかね? 邪道かな...?\nraceでチェックするPromiseは正常処理とタイムアウト処理でもちろん正常処理から結果がくれば普通に、タイムアウトが発動したら上のチェックして後結果を返すと思うのでそれでどうかなと","ts":"1607774291.497400","team":"T03C4RC8V","reactions":[{"name":"me-too","count":1,"users":["U8R597E9H"]}],"replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"AXRr"}]},{"client_msg_id":"31b01c6b-4a3e-47c9-9ebd-648758db0896","type":"message","user":"UP6PA1UBE","text":"タイムアウトをキャンセルできるようにするくらいしか","ts":"1607774043.495200","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"U5Q"}]},{"client_msg_id":"243a75c8-bffb-4eee-8376-7cab5f099dfb","type":"message","user":"U03C71D7H","text":"Promise でタイムアウト処理をする場合、Promise.race() を使うと思うんですが、正規処理が成功した場合、正規処理が失敗した場合、タイムアウトした場合とあり、タイムアウトした時だけ走る処理があるんですが、この処理はタイムアウト以外の時には走らせたくないって場合、別途フラグを用意するしかないですかね…? 今はフラグ用意して正規処理が終わった場合はフラグ立ててタイムアウト時にフラグが立ってたら何もしないってやってるんですが、どうも泥臭くて、他に方法ないのかなぁって考えてます。","ts":"1607707356.494600","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"quv"}]}]
