[{"client_msg_id":"0f4c2eab-dc1a-4bc4-b4f1-1f04fdb2fdd6","type":"message","user":"UG6DF6W87","text":"\u003chttps://tennashi.hatenablog.com/entry/2020/08/30/204210\u003e\n今週号\n今回は gopls の実装詳細に踏み込んでみた","ts":"1598787914.000700","attachments":[{"fallback":"あれ: LSP 実装メモ(gopls cache `Cache` `Session` 編) - あれ","id":1,"title":"LSP 実装メモ(gopls cache `Cache` `Session` 編) - あれ","title_link":"https://tennashi.hatenablog.com/entry/2020/08/30/204210","text":"前回 \u003chttp://tennashi.hatenablog.com|tennashi.hatenablog.com\u003e 今回から少し gopls の cache 機構を集中して読んでいく。 というのも結局 LSP サーバの実装の肝は クライアントから受け取った TextDocument の中身をいつパースするか どのようにパースするか どのように保持するか どうやって TextDocument の中身にアクセスするか なはずで、gopls の場合この cache 機構を読み解くことがこの大部分の理解に繋がると思われるからである。 cache 機構に関連して参考になるドキュメントは以下である。 \u003chttp://github.com|github.com\u003e gopls の cache は 3層になって…","image_url":"https://ogimage.blog.st-hatena.com/17680117127203294009/26006613621764845/1598787730","blocks":null,"ts":1598787730,"service_name":"あれ","service_icon":"https://cdn.image.st-hatena.com/image/apple_touch_icon/ecf1550c56dff759d6bc80aa8ba975b2d0f7b1b4/version=1/https%3A%2F%2Fcdn.user.blog.st-hatena.com%2Fblog_custom_icon%2F154545380%2F1560952205141962","from_url":"https://tennashi.hatenablog.com/entry/2020/08/30/204210","original_url":"https://tennashi.hatenablog.com/entry/2020/08/30/204210"}],"team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"WVEMT"}]},{"client_msg_id":"eb0df42f-8d00-44eb-a49d-137ec0b547f6","type":"message","user":"U8CC7MDCL","text":"OSとして使える最大値以内であれば一ユーザが食いつぶしてもほかユーザは制限を受けないです\ncat /proc/sys/fs/file-max\nでOSとしての最大値確認できたはず","ts":"1598723382.049900","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"96u"}]},{"client_msg_id":"13857203-be80-456b-abaa-1429f8a76ab1","type":"message","user":"U03C71D7H","text":"これって特定のユーザーが使い切ったら root とかでももうダメになるんですかね… (何もわかってない)","ts":"1598719960.047000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"AqB+"}]},{"client_msg_id":"320bcc36-2921-454b-a1c1-302a2eadb682","type":"message","user":"U03C71D7H","text":"ulimit の存在何度でも忘れてしまう…","ts":"1598719919.046400","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"6f6D"}]},{"client_msg_id":"12c386eb-0bb4-4cfb-b635-6fa89218fc32","type":"message","user":"U03C6TEAZ","text":"まだ CentOS が upstart の頃の話だ。なつい。","ts":"1598719648.046000","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"kcG"}]},{"client_msg_id":"8401af04-a592-4cb5-8272-c5a5e6b87cb8","type":"message","user":"U9S4G0LJW","text":"かぶり","ts":"1598719233.045500","team":"T03C4RC8V","reactions":[{"name":"laughing","count":1,"users":["U8CC7MDCL"]}],"replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"tyZL"}]},{"client_msg_id":"1f201bdc-e063-401f-82c7-8f51558270ec","type":"message","user":"U8CC7MDCL","text":"ulimit?","ts":"1598719225.045200","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"a8X"}]},{"client_msg_id":"fbb6be98-5608-4338-a78d-8ef3c5db9d98","type":"message","user":"U9S4G0LJW","text":"ulimitでどうにかなるはず \u003chttp://akishin.hatenablog.jp/entry/20130213/1360711554\u003e","ts":"1598719224.045000","attachments":[{"fallback":"akishin999の日記: Linux サーバでの「Too many open files」対策について - akishin999の日記","id":1,"title":"Linux サーバでの「Too many open files」対策について - akishin999の日記","title_link":"http://akishin.hatenablog.jp/entry/20130213/1360711554","text":"Linux サーバでの「Too many open files」エラー対策について調べたのでまとめてみました。 確認した OS は CentOS 5.9 と CentOS 6.3 です。「Too many open files」は Linux でプロセスが開けるファイルディスクリプタの上限に達してしまうと発生するエラーです。 「ファイルディスクリプタ」という名前ですが、 Linux ではソケットもファイルディスクリプタなので、ファイルを開いた場合だけでなく、ソケットを使って通信を行う場合にもファイルディスクリプタが使用されます。 そのため、Apache や Tomcat などで高負荷なサイトを…","image_url":"https://ogimage.blog.st-hatena.com/13208692334729902439/98012380833892398/1548337387","blocks":null,"ts":1360711554,"service_name":"akishin999の日記","service_icon":"https://cdn.blog.st-hatena.com/images/touch-icon-iphone-retina.png","from_url":"http://akishin.hatenablog.jp/entry/20130213/1360711554","original_url":"http://akishin.hatenablog.jp/entry/20130213/1360711554"}],"team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"HnlI"}]},{"client_msg_id":"39993c65-1778-46df-931c-733619de6fe6","type":"message","user":"U03C71D7H","text":"Linux なんですが、Vim を多数開くと、それぞれが language server を起動してしまい、そいつらがファイルを watch するせいか、システムの別のところで `Failed to allocate directory watch: Too many open files` が多発するようになってしまった。\nこれって Linux の設定とかで上限上げたりして回避とかできるものなんでしょうか?","ts":"1598718762.044600","team":"T03C4RC8V","replace_original":false,"delete_original":false,"blocks":[{"type":"rich_text","block_id":"dKQ"}]}]
